# [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)

time: O(n)\
space: O(n) 

### Idea
Stack

### My Java
``` java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[')
                stack.push(c);
            else {
                if (stack.isEmpty()) return false;
                if (c == ')' && stack.pop() != '(')
                    return false;
                else if (c == '}' && stack.pop() != '{')
                    return false;
                else if (c == ']' && stack.pop() != '[')
                    return false;
            }
        }
        return stack.isEmpty();
    }
}
```

### Editorial Java
``` java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            if (ch == '(') {
                deque.push(')');
            }else if (ch == '{') {
                deque.push('}');
            }else if (ch == '[') {
                deque.push(']');
            } else if (deque.isEmpty() || deque.peek() != ch) {
                return false;
            }else {
                deque.pop();
            }
        }
        return deque.isEmpty();
    }
}
```


# [1047. Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/)

time: O(n) \
space: O(n) 

### Notice
I should combine two if statements into one with || separate

### My Java
``` java
class Solution {
    public String removeDuplicates(String s) {
        Deque<Character> deque = new LinkedList<>();
        for (char c : s.toCharArray()) {
            if (!deque.isEmpty()) {
                char top = deque.getLast();
                if (c == top) {
                    deque.removeLast();
                }
                else {
                    deque.addLast(c);
                }
            }
            else {
                deque.addFirst(c);
            }
        }

        StringBuffer stringBuffer = new StringBuffer();
        while (!deque.isEmpty()) {
           stringBuffer.append(deque.removeFirst());
        }

        return stringBuffer.toString();

    }
}
```

### Editorial Java with Deque
``` java
class Solution {
    public String removeDuplicates(String S) {
        ArrayDeque<Character> deque = new ArrayDeque<>();
        char ch;
        for (int i = 0; i < S.length(); i++) {
            ch = S.charAt(i);
            if (deque.isEmpty() || deque.peek() != ch) {
                deque.push(ch);
            } else {
                deque.pop();
            }
        }
        String str = "";
        while (!deque.isEmpty()) {
            str = deque.pop() + str;
        }
        return str;
    }
}
```

### Editorial Java with StringBuffer only
``` java
class Solution {
    public String removeDuplicates(String s) {
        // 将 res 当做栈
        // 也可以用 StringBuilder 来修改字符串，速度更快
        // StringBuilder res = new StringBuilder();
        StringBuffer res = new StringBuffer();
        // top为 res 的长度
        int top = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            // 当 top > 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--
            if (top >= 0 && res.charAt(top) == c) {
                res.deleteCharAt(top);
                top--;
            // 否则，将该字符 入栈，同时top++
            } else {
                res.append(c);
                top++;
            }
        }
        return res.toString();
    }
}
```


# [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/)

time: O(n) \
space: O(1)

### Idea
done this before

### Java
``` java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = head;
        slow = head;

        while(fast != null && fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) break;
        }

        fast = head;

        while(slow != null && slow.next != null && fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
            if(fast == slow && fast.next == head && slow.next == head) return head;
            if(fast == slow && fast.next != null) return fast;
        }

        return null;
    }
}
```
