# [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)

time: O(n)\
space: O(n) 

### Idea
Stack

### Java
``` java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[')
                stack.push(c);
            else {
                if (stack.isEmpty()) return false;
                if (c == ')' && stack.pop() != '(')
                    return false;
                else if (c == '}' && stack.pop() != '{')
                    return false;
                else if (c == ']' && stack.pop() != '[')
                    return false;
            }
        }
        return stack.isEmpty();
    }
}
```

# [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)

time: O(n) \
space: O(1) 

### Need redo
two pointer problem \
move fast n time, then move fast and slow together \
set pred point to head \
move along with slow \
when fast reach the end of the linked list, slow stop at n node from last node \
and point pred next pointer to slow next node

### Java
``` java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head.next == null) return null; 

        int needToMove = n - 1;
        ListNode slow, fast;
        ListNode pred = new ListNode(0);
        pred.next = head;

        slow = head;
        fast = head;
        while(needToMove > 0) {
            fast = fast.next;
            needToMove--;
        }

        while(fast.next != null) {
            slow = slow.next;
            fast = fast.next;
            pred = pred.next;
        }

        pred.next = slow.next;

        if(slow == head && pred.next != head) return pred.next;

        return head;
    }
}
```


# [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/)

time: O(n) \
space: O(1)

### Idea
done this before

### Java
``` java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = head;
        slow = head;

        while(fast != null && fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) break;
        }

        fast = head;

        while(slow != null && slow.next != null && fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
            if(fast == slow && fast.next == head && slow.next == head) return head;
            if(fast == slow && fast.next != null) return fast;
        }

        return null;
    }
}
```
