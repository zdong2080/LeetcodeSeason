# [654. Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)

time: O($n$)\
space: O($n$) 

### Note
Time complexity and space complexity notice

### python3
``` python3
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        
        maxNum = max(nums)
        maxIndex = nums.index(maxNum)
        node = TreeNode(maxNum)
        node.left = self.constructMaximumBinaryTree(nums[:maxIndex])
        node.right = self.constructMaximumBinaryTree(nums[maxIndex + 1:])

        return node
        
```


# [617. Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/description/)

time: O($m + n$)\
space: O($m + n$) 

### Note
still not 100% understand the return value of tree

### other's solution python3
``` python3
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: 
            return root2
        if not root2: 
            return root1

        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        
        return root1
```

### python3
``` python3
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        
        sumValue = 0
        node = TreeNode(0)

        if root1 and root2:
            node.val = root1.val + root2.val
            node.left = self.mergeTrees(root1.left, root2.left)
            node.right = self.mergeTrees(root1.right, root2.right)

        if root1 and not root2:
            node.val = root1.val
            node.left = self.mergeTrees(root1.left, None)
            node.right = self.mergeTrees(root1.right, None)

        if not root1 and root2:
            node.val = root2.val
            node.left = self.mergeTrees(None, root2.left)
            node.right = self.mergeTrees(None, root2.right)

        return node
```



# [700. Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/description/)

time: O($logn$)\
space: O(1) 

### Bug

### Note

### recursion python3
``` python3
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == val:
            return root
        elif root.val < val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)

```

### iteration python3
``` python3
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        while root:
            if root.val == val:
                break
            elif root.val < val:
                root = root.right
            else:
                root = root.left

        return root

```


# [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

time: O(n)\
space: ?

### Bug
AC!

### Note

### Python3
``` python3
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not len(inorder) and not(postorder):
            return None

        postOrderValue = postorder[-1]
        inOrderIndex = inorder.index(postOrderValue)
        node = TreeNode(postOrderValue)

        node.left = self.buildTree(inorder[:inOrderIndex], postorder[:inOrderIndex])
        node.right = self.buildTree(inorder[inOrderIndex + 1:], postorder[inOrderIndex:len(postorder) - 1])
        return node

```


# [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

time: O(n)\
space: ?

### Bug
AC!

### Note

### Python3
``` python3
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        root = TreeNode(preorder[0])
        index = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:index + 1], inorder[:index])
        root.right = self.buildTree(preorder[index + 1:],inorder[index + 1:])
        return root
        
        
```

