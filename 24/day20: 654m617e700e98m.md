# [654. Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)

time: O($n$)\
space: O($n$) 

### Note
Time complexity and space complexity notice

### python3
``` python3
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        
        maxNum = max(nums)
        maxIndex = nums.index(maxNum)
        node = TreeNode(maxNum)
        node.left = self.constructMaximumBinaryTree(nums[:maxIndex])
        node.right = self.constructMaximumBinaryTree(nums[maxIndex + 1:])

        return node
        
```


# [617. Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/description/)

time: O($m + n$)\
space: O($m + n$) 

### Note


### python3
``` python3
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        
        sumValue = 0
        node = TreeNode(0)

        if root1 and root2:
            node.val = root1.val + root2.val
            node.left = self.mergeTrees(root1.left, root2.left)
            node.right = self.mergeTrees(root1.right, root2.right)

        if root1 and not root2:
            node.val = root1.val
            node.left = self.mergeTrees(root1.left, None)
            node.right = self.mergeTrees(root1.right, None)

        if not root1 and root2:
            node.val = root2.val
            node.left = self.mergeTrees(None, root2.left)
            node.right = self.mergeTrees(None, root2.right)

        return node
```



# [113. Path Sum II](https://leetcode.com/problems/path-sum-ii/description/)

time: O(n)\
space: O(n) 

### Bug
1. res append to lists is actually the reference of it, so in the end the lists is [[][]]
to avoid it, use res.copy() to generate a new res
2. check if root is null

### Note

### Python3
``` python3
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        if not root:
            return []
        lists = []

        def helper(root: Optional[TreeNode], subSum: int, res: List[int]) -> None:
            nonlocal lists
            if not root.left and not root.right:
                if root.val == subSum:
                    res.append(root.val)
                    lists.append(res.copy())
                    res.pop()
                return
            res.append(root.val)
            if root.left:
                helper(root.left, subSum - root.val, res)
            if root.right:
                helper(root.right, subSum - root.val, res)
            res.pop()
            return

        helper(root, targetSum, [])
        return lists

```


# [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

time: O(n)\
space: ?

### Bug
AC!

### Note

### Python3
``` python3
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not len(inorder) and not(postorder):
            return None

        postOrderValue = postorder[-1]
        inOrderIndex = inorder.index(postOrderValue)
        node = TreeNode(postOrderValue)

        node.left = self.buildTree(inorder[:inOrderIndex], postorder[:inOrderIndex])
        node.right = self.buildTree(inorder[inOrderIndex + 1:], postorder[inOrderIndex:len(postorder) - 1])
        return node

```


# [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

time: O(n)\
space: ?

### Bug
AC!

### Note

### Python3
``` python3
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        root = TreeNode(preorder[0])
        index = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:index + 1], inorder[:index])
        root.right = self.buildTree(preorder[index + 1:],inorder[index + 1:])
        return root
        
        
```

